/*
Паттерн строитель - это порождающий паттерн, позволяющий пошагово
создавать объекты разных типов.
Применимость:
	- когда создание объектов разных типов может быть сведено к последовательности
		из одинаковых шагов;
	- есть необходимость создавать шаблонные объекты с разными значениями
		(структуры с разными значениями для одних и тех же полей) при помощи "директоров".
Плюсы:
	- одна и та же последовательность действий может использоваться для
		создания объектов различных типов;
	- сдандартизация создания посредством объявления интерфейса может быть
		понятнее, чем описание полей структур (например, если мы пишем библиотеку);
	- вызов одного метода конструктора может заполнить сразу несколько полей,
		что позволит сократить код.
Минусы:
	- использование "struct literal" в 99% случаев понятнее и короче.
*/

/*
Применим паттерн на следующем кейсе.
Предположим, что мы загорелись идеей продавать "съедобные букеты".
Процентное соотношение мотивации стать бизнесменом к творческим способностям ~ 1/10^6.
Поэтому мы решаем написать программу, собирающую состав букета вместо нас.
Для этого будем пользоваться выдуманным API Wildberries, который предоставляет
возможность получать данные о товарах (категория, популярность, цена и т.д.)
Мы решили стандартизировать создание букета, сведя это к следующим шагам:
	1. Добавляем в букет 3 "вкусняхи";
	2. Добавляем в букет 2 "приколюхи";
	3. Добавляем в букет 1 "полезность";
	4. Добавляем в будет 1 "сюрприз";
	5. Добавляем в букет 100 "наполнителей".
Каждое слово в скобках - категория, из которой мы рандомно выберем один товар
из "топ N товаров".
Так как мы серьёзные бизнесмены, цена букета для нас критична. Поэтому строителей
у нас будет два: первый собирает букет, а второй - чек для букета
(да, это можно сделать проще, но тогда нам некуда применить паттерн).
Букеты для женщин и мужчин отличаются, для них можно создать разных строителей,
а можно - разных директоров. Сейчас я этого делать не буду.
*/

//go run Patterns/P2_builder/main.go Patterns/P2_builder/ticket.go Patterns/P2_builder/bouquet.go

package main

import (
	"fmt"
	"math/rand"
	"time"
)

// Builder - интерфейс абстрактного строителя. Он определяет лишь шаги.
// Конкретная реализация этих шагов у каждого типа-строителя
type Builder interface {
	AddTasty() Builder
	AddPrikol() Builder
	AddUtility() Builder
	AddSurprise() Builder
	AddFiller() Builder
}

type field int

const (
	SKU field = iota
	Price
)

type product struct {
	SKU   string
	Price int
}

var Tasties = []product{
	{"1", 100}, {"2", 150}, {"3", 200}, {"4", 250}, {"5", 250},
}

var Prikols = []product{
	{"11", 10}, {"12", 20}, {"13", 10}, {"14", 40}, {"15", 50},
}

var Utils = []product{
	{"21", 110}, {"22", 120}, {"23", 130}, {"24", 140},
}

var Surprises = []product{
	{"31", 100}, {"32", 150}, {"33", 200}, {"34", 250}, {"35", 250},
}

var Fillers = []product{
	{"41", 10}, {"42", 15}, {"43", 5},
}

func main() {
	b := NewBouquetBuilder1()
	t := NewTicketBuilder1()

	b1 := b.AddTasty().AddPrikol().AddUtility().AddSurprise().AddFiller().Build()
	t1 := t.AddTasty().AddPrikol().AddUtility().AddSurprise().AddFiller().Build()

	fmt.Println(b1)
	fmt.Println(t1)
}

// GetRandS просто имитирует запрос к API, в ней нет смысла
func GetRandS(field field, category []product) string {
	var value string
	rand.Seed(time.Now().UnixMilli())

	prod := rand.Intn(len(category))

	// если вдруг появятся новые поля, свитч будет уместен
	switch {
	case field == SKU:
		value = category[prod].SKU
	}

	return value
}

// GetRandD могла бы быть GetRand() вместе с GetRandS, но я боюсь дженериков
func GetRandD(field field, category []product) int {
	var value int
	rand.Seed(time.Now().UnixMilli())

	prod := rand.Intn(len(category))

	switch {
	case field == Price:
		value = category[prod].Price
	}

	return value
}
